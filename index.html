<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Treasure Dig ‚Äî Windows Security Quiz</title>
<style>
  :root{
    --bg1:#04060f;
    --bg2:#08162e;
    --ink:#eaf0ff;
    --muted:#a9b6d6;
    --line: rgba(255,255,255,.12);

    --blue:#4aa3ff;
    --green:#3ddc97;
    --amber:#ffcc66;
    --red:#ff5c6c;

    --panel: rgba(0,0,0,.24);
    --panel2: rgba(255,255,255,.05);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:var(--ink);
    background:
      radial-gradient(1200px 760px at 18% 12%, rgba(74,163,255,.15), transparent 55%),
      radial-gradient(900px 620px at 82% 16%, rgba(61,220,151,.10), transparent 60%),
      radial-gradient(900px 600px at 70% 86%, rgba(255,204,102,.10), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
    overflow:hidden;
  }
  .wrap{
    height:100%;
    max-width: 1320px;
    margin: 0 auto;
    padding:14px;
    display:grid;
    grid-template-columns: 1.25fr .75fr;
    gap:14px;
  }
  @media (max-width: 980px){
    body{overflow:auto}
    .wrap{grid-template-columns:1fr; grid-template-rows: 1.05fr .95fr}
  }
  .card{
    border:1px solid var(--line);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
    box-shadow: 0 18px 52px rgba(0,0,0,.50);
    overflow:hidden;
    position:relative;
  }
  .head{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    background: rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  }
  .head .t{font-weight:950;font-size:13px}
  .head .s{color:var(--muted);font-size:12px}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:7px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.05);
    color:var(--muted);
    font-size:12px;
    white-space:nowrap;
  }
  .chip b{color:var(--ink)}
  .btn{
    border-radius:14px;
    padding:10px 12px;
    border:1px solid var(--line);
    background: rgba(74,163,255,.14);
    color:var(--ink);
    font-weight:950;
    cursor:pointer;
  }
  .btn:hover{border-color: rgba(74,163,255,.40)}
  .btn.ghost{background: rgba(255,255,255,.04)}
  .btn:disabled{opacity:.55;cursor:not-allowed}

  .game{position:relative;height:100%;min-height: 560px}
  canvas{width:100%;height:100%;display:block}

  .sideBody{padding:14px;display:flex;flex-direction:column;gap:12px}
  .panel{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .big{font-weight:950;font-size:13px}
  .small{color:var(--muted);font-size:12.5px;line-height:1.45;margin-top:6px}
  .bar{
    margin-top:10px;height:10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.08);
    overflow:hidden;
  }
  .bar i{display:block;height:100%;width:0%;background: rgba(61,220,151,.85);transition: width .35s ease}

  .q{font-weight:950;font-size:13px;line-height:1.45}
  .opts{display:grid;gap:10px;margin-top:12px}
  .opt{
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:10px 12px;
    cursor:pointer;
    display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
    transition: transform .12s ease, border-color .18s ease, background .18s ease;
  }
  .opt:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.20); background: rgba(255,255,255,.06)}
  .opt[disabled]{opacity:.55;cursor:not-allowed}
  .left{display:flex;gap:10px;align-items:flex-start}
  .badge{
    width:28px;height:28px;border-radius:10px;
    border:1px solid rgba(74,163,255,.22);
    background: rgba(74,163,255,.12);
    display:grid;place-items:center;
    flex:0 0 auto;
    font-weight:950;
  }
  .kbd{
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.28);
    color:var(--muted);
    font-size:11px;
    white-space:nowrap;
  }

  .fb{
    display:none;
    margin-top:12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .fb.show{display:block}
  .fb.good{border-color: rgba(61,220,151,.25); background: linear-gradient(180deg, rgba(61,220,151,.10), rgba(0,0,0,.22))}
  .fb.bad{border-color: rgba(255,92,108,.25); background: linear-gradient(180deg, rgba(255,92,108,.10), rgba(0,0,0,.22))}
  .fb .t{font-weight:950}
  .fb .p{margin-top:6px;color:var(--muted);font-size:12.5px;line-height:1.45}
  .rowBtns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}

  .hint{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    padding:12px;
    color:var(--muted);
    font-size:12.5px;
    line-height:1.45;
  }
</style>
</head>
<body>
<div class="wrap">

  <!-- GAME -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Treasure Dig ‚Äî Windows Security</div>
        <div class="s">Pick a rock tile ‚Üí answer MCQ ‚Üí mine loot. Reach 5 chests.</div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <div class="chip">Chests <b id="treasureText">0/5</b></div>
        <div class="chip">Energy <b id="energyText">14</b></div>
        <div class="chip">Streak <b id="streakText">0</b></div>
        <button class="btn ghost" id="resetBtn" type="button">Reset</button>
      </div>
    </div>
    <div class="game">
      <canvas id="cv"></canvas>
    </div>
  </div>

  <!-- MCQ PANEL -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Question Panel</div>
        <div class="s">Options shuffle every time (balanced answers).</div>
      </div>
      <div class="chip">Score <b id="scoreText">0</b></div>
    </div>

    <div class="sideBody">
      <div class="panel">
        <div class="row">
          <div class="big">How to play</div>
          <div class="chip">Goal <b>5 chests</b></div>
        </div>
        <div class="small">
          1) Click a rock tile to start digging.<br/>
          2) Answer the MCQ to mine that tile.<br/>
          3) Correct answers increase streak (bonus score). Wrong breaks streak.
        </div>
        <div class="bar" aria-hidden="true"><i id="progBar"></i></div>
      </div>

      <div class="panel">
        <div class="q" id="qText">Click a rock tile to start‚Ä¶</div>
        <div class="opts" id="opts"></div>

        <div class="fb" id="fb">
          <div class="t" id="fbT">‚Äî</div>
          <div class="p" id="fbP">‚Äî</div>
          <div class="rowBtns">
            <button class="btn" id="continueBtn" type="button">Continue</button>
            <button class="btn ghost" id="retryBtn" type="button">Try another question</button>
          </div>
        </div>
      </div>

      <div class="hint">
        To change questions: edit <b>QUESTION_BANK</b> in the code.
      </div>
    </div>
  </div>

</div>

<script>
/* =========================================================
   Treasure Dig ‚Äî Windows Security Quiz (Graphic-rich, simple logic)
   Visual upgrades:
   - Multi-layer cave background + parallax
   - Torch glow + floating dust motes
   - Miner character + pickaxe swing when mining
   - Better rock texture + cracks
   - Loot animations: chest pop, gem sparkle, rare artifact banner
   - Streak bonus + combo floaties
   Learning:
   - MCQs derived from your "Windows Security" and "User Account Security" chapters.
========================================================= */

/* ---------- MCQs (from your uploaded chapters) ---------- */
const QUESTION_BANK = [
  // Privacy / installation settings
  { q:"During Windows setup, what is recommended instead of accepting Express Settings?",
    options:["Choose Customise settings","Disable the display driver","Skip creating a user","Turn off the PC immediately"],
    correct:0,
    ok:"Customise settings lets you reduce invasive data sharing while keeping needed security options.",
    bad:"Express Settings enables more invasive defaults." },

  { q:"In privacy setup suggestions, which protection is recommended to KEEP enabled for security?",
    options:["SmartScreen online service","Advertising ID personalization","Typing/inking data sharing","Location services for all apps"],
    correct:0,
    ok:"SmartScreen helps protect against malicious content and downloads.",
    bad:"Those options increase tracking or exposure." },

  { q:"What is the goal of turning off 'Personalized ads in this browser'?",
    options:["Reduce tracking-based advertising","Increase download speed","Disable Windows updates","Enable admin access"],
    correct:0,
    ok:"It limits personalized advertising and related tracking.",
    bad:"It does not affect updates or admin access." },

  { q:"Turning off Location in Privacy settings primarily prevents‚Ä¶",
    options:["Third parties collecting location data","Windows from booting","All apps from running","Wi-Fi from working"],
    correct:0,
    ok:"It limits sharing of location data with apps/third parties.",
    bad:"Location toggles do not break boot or Wi-Fi." },

  { q:"What is recommended for Camera / Microphone privacy?",
    options:["Turn off access if not needed, and restrict apps","Allow all apps always","Camera permissions do not matter","Disable security prompts permanently"],
    correct:0,
    ok:"Reduce attack surface by limiting app access.",
    bad:"Over-permissioning increases risk." },

  { q:"What is recommended under Feedback & diagnostics?",
    options:["Never ask for feedback and send Basic diagnostics","Always ask for feedback and send Full diagnostics","Disable the keyboard driver","Only send diagnostics to third-party apps"],
    correct:0,
    ok:"This reduces unnecessary data sharing while keeping basic diagnostics.",
    bad:"Full diagnostics increases data sharing." },

  { q:"Background apps setting is used to‚Ä¶",
    options:["Stop apps running in background when not needed","Encrypt the hard drive","Change user password","Enable Windows Firewall"],
    correct:0,
    ok:"It reduces background activity and unnecessary data/notifications.",
    bad:"It is unrelated to encryption, passwords, or firewall." },

  // Accounts / passwords / screen lock
  { q:"Why should each person have a unique Windows user account?",
    options:["Better security and accountability","To increase screen brightness","To disable antivirus","To avoid updates"],
    correct:0,
    ok:"Separate accounts reduce risk and improve accountability.",
    bad:"It does not impact brightness or updates." },

  { q:"If you press Windows+L and return without entering anything, it usually means‚Ä¶",
    options:["Your account has no password","Your firewall is off","Your disk is encrypted","SmartScreen is disabled"],
    correct:0,
    ok:"Windows+L locks the screen; no prompt suggests no password protection.",
    bad:"Lock screen behavior is about account sign-in settings." },

  { q:"Where do you add a password in Windows settings (as described in the chapter)?",
    options:["Settings ‚Üí Accounts ‚Üí Sign-in options ‚Üí Password (Add)","Control Panel ‚Üí Mouse","Task Manager ‚Üí Startup","File Explorer ‚Üí View tab"],
    correct:0,
    ok:"Password is set under Accounts and Sign-in options.",
    bad:"Those locations don‚Äôt manage account passwords." },

  { q:"When creating a password, the chapter warns you to be careful with‚Ä¶",
    options:["Password hint revealing too much","Monitor resolution","Printer queue size","Folder icon color"],
    correct:0,
    ok:"Hints can leak information about the password.",
    bad:"Hint guidance is security-focused." },

  { q:"A good inactive screen lock timeout suggested is around‚Ä¶",
    options:["3 minutes","30 minutes","3 hours","Never lock"],
    correct:0,
    ok:"Short timeouts help prevent walk-up access.",
    bad:"Long or never-lock increases risk in offices." },

  // Updates / firewall / malware avoidance
  { q:"Why are system updates important?",
    options:["They patch vulnerabilities exploited by malware","They permanently stop phishing","They remove the need for backups","They increase hardware RAM"],
    correct:0,
    ok:"Updates close known security holes.",
    bad:"Updates don‚Äôt replace backups or stop all phishing." },

  { q:"Windows Firewall is essential because it‚Ä¶",
    options:["Blocks unauthorized access based on rules","Cleans dust from the CPU","Encrypts your email","Upgrades your GPU drivers"],
    correct:0,
    ok:"Firewall filters network traffic and blocks unauthorized access.",
    bad:"Firewall does not perform hardware cleaning or driver upgrades." },

  { q:"SmartScreen helps protect users mainly from‚Ä¶",
    options:["Malware and phishing by checking URLs/apps","Low battery problems","Keyboard failures","Screen flicker"],
    correct:0,
    ok:"SmartScreen warns/blocks malicious content based on reputation checks.",
    bad:"It is a security feature, not a hardware fix." },

  { q:"Windows Defender is used to‚Ä¶",
    options:["Detect and remove malware, and run scans","Create user accounts","Disable location services","Change file extensions"],
    correct:0,
    ok:"Defender scans and helps remove malware.",
    bad:"Those are different settings areas." },

  { q:"Why is it useful to show file extensions in Windows?",
    options:["So disguised files like .EXE aren‚Äôt mistaken for safe documents","To make files larger","To speed up downloads","To disable encryption"],
    correct:0,
    ok:"Hidden extensions can be abused to trick users.",
    bad:"File extensions visibility is about safety, not speed or encryption." },

  { q:"AutoPlay is recommended to be disabled because‚Ä¶",
    options:["Removable media can trigger unwanted actions and malware risk","It improves audio quality too much","It slows the CPU permanently","It deletes user accounts"],
    correct:0,
    ok:"AutoPlay can increase exposure from removable media.",
    bad:"It doesn‚Äôt affect audio quality or accounts." },

  // BitLocker / encryption
  { q:"Why is full-disk encryption (BitLocker) useful?",
    options:["Protects files if someone gets physical access to the computer","Makes Wi-Fi faster","Prevents all phishing","Guarantees no malware"],
    correct:0,
    ok:"Encryption protects data at rest if device is stolen or accessed physically.",
    bad:"Encryption is not an anti-phishing or anti-malware guarantee." },

  { q:"BitLocker guidance emphasizes keeping a copy of‚Ä¶",
    options:["Recovery key in a safe location","Screen wallpaper","Mouse settings","Bluetooth name"],
    correct:0,
    ok:"Recovery keys are critical if the password is lost.",
    bad:"Only recovery keys are central for decryption recovery." },

  { q:"If a device lacks a TPM, the guide notes BitLocker may still work by enabling‚Ä¶",
    options:["Allow BitLocker without a compatible TPM (password/USB key)","Guest account only","Express settings","AutoPlay for all media"],
    correct:0,
    ok:"Policy can allow BitLocker with password or startup key on USB.",
    bad:"Those options are unrelated to TPM requirements." },
];

/* ---------- Helpers ---------- */
function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function rand(a,b){ return a + Math.random()*(b-a); }
function randi(a,b){ return Math.floor(rand(a,b+1)); }

/* ---------- DOM ---------- */
const el = {
  cv: document.getElementById("cv"),
  treasureText: document.getElementById("treasureText"),
  energyText: document.getElementById("energyText"),
  streakText: document.getElementById("streakText"),
  scoreText: document.getElementById("scoreText"),
  progBar: document.getElementById("progBar"),
  resetBtn: document.getElementById("resetBtn"),

  qText: document.getElementById("qText"),
  opts: document.getElementById("opts"),
  fb: document.getElementById("fb"),
  fbT: document.getElementById("fbT"),
  fbP: document.getElementById("fbP"),
  continueBtn: document.getElementById("continueBtn"),
  retryBtn: document.getElementById("retryBtn"),
};

/* ---------- Config ---------- */
const GOAL_TREASURE = 5;
const START_ENERGY = 14;
const GRID_COLS = 8;
const GRID_ROWS = 6;

const CONTENT = { EMPTY:"empty", GEM:"gem", CHEST:"chest", ART:"artifact" };

/* ---------- State ---------- */
const state = {
  energy: START_ENERGY,
  score: 0,
  treasures: 0,
  streak: 0,
  gameOver: false,

  grid: [],
  selected: null,
  locked: false,
  currentQ: null,

  flash: 0,
  shake: 0,

  // Visual
  particles: [],
  dust: [],
  motes: [],
  floaties: [],
  banners: [],
  miner: { x:0, y:0, tx:0, ty:0, swing:0, face:1 },

  t: 0
};

/* ---------- Canvas ---------- */
const ctx = el.cv.getContext("2d", {alpha:false});
let W=0,H=0,dpr=1;
let board = {x:0,y:0,w:0,h:0,cell:0,pad:0};

function resize(){
  const r = el.cv.getBoundingClientRect();
  dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(r.width*dpr);
  H = Math.floor(r.height*dpr);
  el.cv.width = W;
  el.cv.height = H;

  const pad = 24*dpr;
  const top = 18*dpr;
  const bw = W - pad*2;
  const bh = H - pad*2 - 70*dpr;
  const cell = Math.floor(Math.min(bw/GRID_COLS, bh/GRID_ROWS));
  const gw = cell*GRID_COLS;
  const gh = cell*GRID_ROWS;

  board = {
    cell,
    pad: Math.floor(cell*0.12),
    x: Math.floor((W-gw)/2),
    y: Math.floor(top + (bh-gh)/2),
    w: gw,
    h: gh
  };
}
window.addEventListener("resize", resize);

/* ---------- Grid ---------- */
function buildGrid(){
  const total = GRID_COLS*GRID_ROWS;
  const contents = Array(total).fill(CONTENT.EMPTY);

  // ensure chests
  const chestCount = GOAL_TREASURE + 2;
  let placed = 0;
  while(placed < chestCount){
    const k = randi(0, total-1);
    if(contents[k] === CONTENT.EMPTY){
      contents[k] = CONTENT.CHEST;
      placed++;
    }
  }

  // gems
  const gemCount = Math.floor(total*0.22);
  let gplaced = 0;
  while(gplaced < gemCount){
    const k = randi(0, total-1);
    if(contents[k] === CONTENT.EMPTY){
      contents[k] = CONTENT.GEM;
      gplaced++;
    }
  }

  // rare artifacts
  const artCount = 2;
  let aplaced = 0;
  while(aplaced < artCount){
    const k = randi(0, total-1);
    if(contents[k] === CONTENT.EMPTY){
      contents[k] = CONTENT.ART;
      aplaced++;
    }
  }

  state.grid = [];
  let idx = 0;
  for(let r=0;r<GRID_ROWS;r++){
    const row = [];
    for(let c=0;c<GRID_COLS;c++){
      row.push({
        revealed:false,
        breaking:0,
        content: contents[idx],
        sparkle: Math.random(),
        cracked: 0,
        heat: rand(0,1), // torch warmth highlight
      });
      idx++;
    }
    state.grid.push(row);
  }
}

/* ---------- MCQ ---------- */
function pickQuestion(){
  const base = QUESTION_BANK[randi(0, QUESTION_BANK.length-1)];
  const opts = base.options.map((t,i)=> ({t, orig:i}));
  const sh = shuffle(opts);
  const newCorrect = sh.findIndex(o => o.orig === base.correct);
  return { q: base.q, options: sh.map(o=>o.t), correct: newCorrect, ok: base.ok, bad: base.bad };
}

function lockOptions(v){
  [...el.opts.querySelectorAll("button")].forEach(x=> x.disabled = v);
}

function showQuestion(){
  state.currentQ = pickQuestion();
  el.qText.textContent = state.currentQ.q;
  el.opts.innerHTML = "";
  el.fb.className = "fb";
  state.locked = false;

  const badges = ["A","B","C","D"];
  state.currentQ.options.forEach((t,i)=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "opt";
    b.innerHTML = `
      <div class="left">
        <div class="badge">${badges[i]}</div>
        <div style="font-weight:850;line-height:1.35">${t}</div>
      </div>
      <div class="kbd">${i+1}</div>
    `;
    b.addEventListener("click", ()=> answer(i));
    el.opts.appendChild(b);
  });
}

function answer(i){
  if(state.locked || !state.selected || state.gameOver) return;
  state.locked = true;
  lockOptions(true);

  const ok = (i === state.currentQ.correct);

  // Energy cost always (keeps pressure)
  state.energy = Math.max(0, state.energy - 1);

  if(ok){
    state.streak += 1;
    const streakBonus = Math.min(12, state.streak) * 2;
    state.score += 10 + streakBonus;

    el.fb.className = "fb show good";
    el.fbT.textContent = "Correct ‚Äî Tile mined";
    el.fbP.textContent = state.currentQ.ok + (state.streak >= 2 ? ` (Streak bonus +${streakBonus})` : "");

    const {r,c} = state.selected;
    mineTile(r,c, true);

  }else{
    state.streak = 0;
    state.score = Math.max(0, state.score - 2);

    el.fb.className = "fb show bad";
    el.fbT.textContent = "Not correct";
    el.fbP.textContent = state.currentQ.bad;

    // shake + flash + dust
    state.flash = 1.0;
    state.shake = 1.0;
    const {r,c} = state.selected;
    const p = cellCenter(r,c);
    dustBurst(p.x,p.y, false);
    floaty(p.x, p.y - 10*dpr, "Streak broken", "bad");
  }

  updateHUD();

  if(state.treasures >= GOAL_TREASURE){
    endGame(true);
  }else if(state.energy <= 0){
    endGame(false);
  }
}

function endGame(win){
  state.gameOver = true;
  el.opts.innerHTML = "";
  el.fb.className = "fb show " + (win ? "good" : "bad");
  el.fbT.textContent = win ? "üéâ Mission Complete!" : "Energy finished";
  el.fbP.textContent = win
    ? "You secured the system knowledge vault. Reset to play again."
    : "Reset and try to find 5 chests within the energy limit.";
  el.continueBtn.textContent = "Reset";
  el.retryBtn.style.display = "none";
  el.qText.textContent = win ? "Well done." : "Try again.";
}

el.continueBtn.addEventListener("click", ()=>{
  if(state.gameOver){ reset(); return; }
  el.fb.className = "fb";
  el.qText.textContent = "Click another rock tile to dig‚Ä¶";
  el.opts.innerHTML = "";
  state.selected = null;
  state.locked = false;
});
el.retryBtn.addEventListener("click", ()=>{
  if(state.gameOver) return;
  showQuestion();
});
el.resetBtn.addEventListener("click", reset);

document.addEventListener("keydown", (e)=>{
  const n = parseInt(e.key,10);
  if(n>=1 && n<=4){
    const btn = el.opts.querySelectorAll("button")[n-1];
    if(btn && !btn.disabled) btn.click();
  }
});

/* ---------- Tile / Mining ---------- */
function cellRect(r,c){
  const x = board.x + c*board.cell;
  const y = board.y + r*board.cell;
  return {x,y,w:board.cell,h:board.cell};
}
function cellCenter(r,c){
  const rr = cellRect(r,c);
  return {x: rr.x + rr.w/2, y: rr.y + rr.h/2};
}

function mineTile(r,c){
  const tile = state.grid[r][c];
  if(tile.revealed) return;

  tile.breaking = Math.max(tile.breaking, 0.01);
  tile.cracked = 1;

  const p = cellCenter(r,c);

  // miner moves + swings
  state.miner.tx = p.x - board.cell*0.42;
  state.miner.ty = p.y + board.cell*0.18;
  state.miner.face = (state.miner.tx > state.miner.x) ? 1 : -1;
  state.miner.swing = 1.0;

  dustBurst(p.x,p.y, true);
}

function applyReveal(r,c){
  const tile = state.grid[r][c];
  if(tile.revealed) return;
  tile.revealed = true;

  const p = cellCenter(r,c);

  if(tile.content === CONTENT.GEM){
    state.score += 15;
    floaty(p.x,p.y, "üíé +15", "good");
    sparkleBurst(p.x,p.y);
  }else if(tile.content === CONTENT.CHEST){
    state.treasures += 1;
    state.score += 35;
    chestPop(p.x,p.y);
    bigSparkle(p.x,p.y);
  }else if(tile.content === CONTENT.ART){
    state.score += 60;
    banner("RARE ARTIFACT FOUND", "amber");
    bigSparkle(p.x,p.y);
    floaty(p.x,p.y, "üè∫ +60", "good");
  }else{
    state.score += 2;
    floaty(p.x,p.y, "+2", "muted");
  }

  updateHUD();
}

function banner(text, theme){
  state.banners.push({ text, theme, life: 130 });
}

/* ---------- Particles / Effects ---------- */
function dustBurst(x,y, good){
  const n = good ? 26 : 18;
  for(let i=0;i<n;i++){
    state.dust.push({
      x,y,
      vx: rand(-1.9,1.9),
      vy: rand(-2.8,-0.7),
      life: good ? rand(20,38) : rand(16,28),
      s: rand(1.1,2.6),
      good
    });
  }
}
function sparkleBurst(x,y){
  for(let i=0;i<18;i++){
    state.particles.push({
      x,y,
      vx: rand(-2.4,2.4),
      vy: rand(-3.2,-0.9),
      life: rand(22,40),
      s: rand(1.0,2.1),
      kind: "spark"
    });
  }
}
function bigSparkle(x,y){
  for(let i=0;i<34;i++){
    state.particles.push({
      x,y,
      vx: rand(-2.8,2.8),
      vy: rand(-3.6,-1.1),
      life: rand(28,52),
      s: rand(1.2,2.4),
      kind: "spark"
    });
  }
}
function chestPop(x,y){
  // A few "coin" particles + chest bounce illusion
  for(let i=0;i<20;i++){
    state.particles.push({
      x,y,
      vx: rand(-3.0,3.0),
      vy: rand(-4.0,-1.2),
      life: rand(28,46),
      s: rand(1.0,2.2),
      kind: "coin"
    });
  }
  floaty(x, y - 6*dpr, "üéÅ CHEST!", "good");
}
function floaty(x,y,text,kind){
  state.floaties.push({
    x,y,
    vy: rand(-0.55,-1.0),
    life: 76,
    text,
    kind
  });
}

/* dust motes floating */
function seedMotes(){
  state.motes.length = 0;
  const count = Math.floor((W*H) / (22000*dpr*dpr));
  for(let i=0;i<count;i++){
    state.motes.push({
      x: rand(0,W),
      y: rand(0,H),
      s: rand(0.6,1.6)*dpr,
      a: rand(0.05,0.20),
      vx: rand(-0.10,0.10)*dpr,
      vy: rand(-0.06,0.08)*dpr
    });
  }
}

/* ---------- HUD ---------- */
function updateHUD(){
  el.treasureText.textContent = `${state.treasures}/${GOAL_TREASURE}`;
  el.energyText.textContent = `${state.energy}`;
  el.streakText.textContent = `${state.streak}`;
  el.scoreText.textContent = `${state.score}`;
  el.progBar.style.width = `${(state.treasures/GOAL_TREASURE)*100}%`;
}

/* ---------- Input ---------- */
function canvasToWorld(evt){
  const rect = el.cv.getBoundingClientRect();
  const x = (evt.clientX - rect.left) * dpr;
  const y = (evt.clientY - rect.top) * dpr;
  return {x,y};
}

el.cv.addEventListener("click", (evt)=>{
  if(state.gameOver) return;
  if(state.locked) return;
  if(el.fb.classList.contains("show")) return;

  const p = canvasToWorld(evt);
  if(p.x < board.x || p.x > board.x+board.w || p.y < board.y || p.y > board.y+board.h) return;

  const c = Math.floor((p.x - board.x) / board.cell);
  const r = Math.floor((p.y - board.y) / board.cell);
  if(r<0||r>=GRID_ROWS||c<0||c>=GRID_COLS) return;

  const tile = state.grid[r][c];
  if(tile.revealed) return;

  state.selected = {r,c};
  showQuestion();
});

/* ---------- Drawing ---------- */
function rr(x,y,w,h,r){
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function glow(x,y,rad,c0){
  const g = ctx.createRadialGradient(x,y,0,x,y,rad);
  g.addColorStop(0,c0);
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill();
}

function drawBackground(t){
  ctx.fillStyle = "#040611";
  ctx.fillRect(0,0,W,H);

  // Cave layers (parallax)
  const p1 = Math.sin(t*0.22)*10*dpr;
  const p2 = Math.sin(t*0.18+2.2)*14*dpr;
  const p3 = Math.sin(t*0.15+4.2)*18*dpr;

  // deep cave gradient
  const g0 = ctx.createLinearGradient(0,0,0,H);
  g0.addColorStop(0,"#050a1b");
  g0.addColorStop(1,"#071f3d");
  ctx.fillStyle = g0;
  ctx.fillRect(0,0,W,H);

  // far glow pockets
  glow(W*0.18, H*0.16, 260*dpr, "rgba(74,163,255,.10)");
  glow(W*0.78, H*0.22, 220*dpr, "rgba(61,220,151,.08)");
  glow(W*0.64, H*0.84, 280*dpr, "rgba(255,204,102,.10)");

  // stalactites silhouette
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,.30)";
  ctx.beginPath();
  ctx.moveTo(0, 40*dpr + p1);
  for(let x=0;x<=W;x+=60*dpr){
    ctx.lineTo(x+20*dpr, 16*dpr + (x%120===0? 20*dpr: 40*dpr) + p1);
    ctx.lineTo(x+45*dpr, 52*dpr + (x%180===0? 8*dpr: 26*dpr) + p1);
  }
  ctx.lineTo(W,0); ctx.lineTo(0,0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // mid cave waves
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,.20)";
  ctx.beginPath();
  ctx.moveTo(0, H*0.70 + p2);
  ctx.bezierCurveTo(W*0.25, H*0.64 + p2, W*0.35, H*0.80 + p2, W*0.55, H*0.74 + p2);
  ctx.bezierCurveTo(W*0.74, H*0.68 + p2, W*0.86, H*0.86 + p2, W, H*0.78 + p2);
  ctx.lineTo(W,H); ctx.lineTo(0,H);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // torch glow (follows miner position)
  glow(state.miner.x + 18*dpr, state.miner.y - 30*dpr, 220*dpr, "rgba(255,204,102,.12)");
  glow(state.miner.x + 18*dpr, state.miner.y - 30*dpr, 120*dpr, "rgba(255,204,102,.10)");

  // floating motes
  ctx.save();
  for(const m of state.motes){
    ctx.globalAlpha = m.a;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.beginPath();
    ctx.arc(m.x, m.y, m.s, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawBoardFrame(){
  ctx.save();
  glow(board.x+board.w*0.5, board.y+board.h*0.5, board.w*0.66, "rgba(74,163,255,.08)");
  rr(board.x-10*dpr, board.y-10*dpr, board.w+20*dpr, board.h+20*dpr, 22*dpr);
  ctx.fillStyle = "rgba(0,0,0,.20)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 2*dpr;
  ctx.stroke();
  ctx.restore();
}

function drawMiner(t){
  // Smooth move toward target
  state.miner.x += (state.miner.tx - state.miner.x) * 0.08;
  state.miner.y += (state.miner.ty - state.miner.y) * 0.08;

  const x = state.miner.x, y = state.miner.y;
  const face = state.miner.face;

  // swing decay
  state.miner.swing = Math.max(0, state.miner.swing - 0.04);

  const bob = Math.sin(t*6)*1.2*dpr;
  const swing = state.miner.swing * Math.sin(t*14) * 1.0;

  ctx.save();
  // shadow
  ctx.globalAlpha = 0.55;
  rr(x-18*dpr, y+12*dpr, 44*dpr, 10*dpr, 8*dpr);
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.fill();
  ctx.globalAlpha = 1;

  // body
  rr(x-10*dpr, y-16*dpr + bob, 26*dpr, 30*dpr, 10*dpr);
  ctx.fillStyle = "rgba(74,163,255,.18)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 2*dpr;
  ctx.stroke();

  // head
  ctx.beginPath();
  ctx.arc(x+3*dpr, y-24*dpr + bob, 10*dpr, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,.14)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.stroke();

  // helmet lamp glow
  glow(x+6*dpr, y-26*dpr + bob, 90*dpr, "rgba(255,204,102,.12)");
  ctx.beginPath();
  ctx.arc(x+8*dpr, y-26*dpr + bob, 2.4*dpr, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,204,102,.95)";
  ctx.fill();

  // pickaxe (simple)
  ctx.translate(x+14*dpr, y-10*dpr + bob);
  ctx.scale(face, 1);
  ctx.rotate(-0.4 + swing);
  // handle
  rr(-2*dpr, -2*dpr, 28*dpr, 5*dpr, 3*dpr);
  ctx.fillStyle = "rgba(255,204,102,.30)";
  ctx.fill();
  // blade
  rr(22*dpr, -7*dpr, 10*dpr, 14*dpr, 4*dpr);
  ctx.fillStyle = "rgba(255,255,255,.16)";
  ctx.fill();
  ctx.restore();
}

function drawTile(r,c,t){
  const tile = state.grid[r][c];
  const R = cellRect(r,c);
  const pad = board.pad;

  const x = R.x + pad;
  const y = R.y + pad;
  const w = R.w - pad*2;
  const h = R.h - pad*2;

  const isSel = state.selected && state.selected.r===r && state.selected.c===c && !tile.revealed;

  ctx.save();

  // base cell
  rr(x,y,w,h,18*dpr);
  ctx.fillStyle = "rgba(255,255,255,.035)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 2*dpr;
  ctx.stroke();

  // heat glow from "torch"
  const cx = x+w/2, cy = y+h/2;
  const dist = Math.hypot((cx - (state.miner.x+10*dpr))/dpr, (cy - (state.miner.y-20*dpr))/dpr);
  const warm = clamp(1 - dist/240, 0, 1) * 0.35;
  if(warm>0) glow(cx,cy, 70*dpr, `rgba(255,204,102,${0.10+warm})`);

  if(isSel){
    glow(cx,cy, 58*dpr, "rgba(74,163,255,.18)");
    // subtle pulse ring
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(74,163,255,.55)";
    ctx.lineWidth = 2*dpr;
    ctx.beginPath();
    ctx.arc(cx,cy, (w*0.34) + Math.sin(t*4)*2*dpr, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  if(!tile.revealed){
    // rock texture
    const g = ctx.createLinearGradient(x,y,x+w,y+h);
    g.addColorStop(0,"rgba(255,255,255,.10)");
    g.addColorStop(1,"rgba(0,0,0,.30)");
    rr(x+2*dpr,y+2*dpr,w-4*dpr,h-4*dpr,16*dpr);
    ctx.fillStyle = g;
    ctx.fill();

    // speckles
    ctx.save();
    ctx.globalAlpha = 0.14;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    for(let k=0;k<8;k++){
      const sx = x + rand(6*dpr, w-6*dpr);
      const sy = y + rand(6*dpr, h-6*dpr);
      ctx.fillRect(sx, sy, 2*dpr, 2*dpr);
    }
    ctx.restore();

    // cracks if mined
    if(tile.cracked){
      ctx.strokeStyle = "rgba(255,204,102,.22)";
      ctx.lineWidth = 2*dpr;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x+w*0.18, y+h*0.70);
      ctx.lineTo(x+w*0.44, y+h*0.36);
      ctx.lineTo(x+w*0.78, y+h*0.58);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+w*0.44, y+h*0.36);
      ctx.lineTo(x+w*0.34, y+h*0.18);
      ctx.stroke();
    }

    // breaking overlay
    if(tile.breaking > 0){
      const alpha = clamp(tile.breaking*1.6,0,1)*0.65;
      ctx.globalAlpha = alpha;
      rr(x+6*dpr,y+6*dpr,w-12*dpr,h-12*dpr,14*dpr);
      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // hint pickaxe icon
    if(isSel){
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(234,240,255,.95)";
      ctx.font = `${14*dpr}px system-ui, Segoe UI, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("‚õèÔ∏è", cx, cy + Math.sin((t + tile.sparkle)*2.4)*1.2*dpr);
      ctx.globalAlpha = 1;
    }
  }else{
    // revealed pit
    rr(x+2*dpr,y+2*dpr,w-4*dpr,h-4*dpr,16*dpr);
    ctx.fillStyle = "rgba(0,0,0,.30)";
    ctx.fill();

    let icon = "¬∑";
    if(tile.content === CONTENT.GEM) icon = "üíé";
    if(tile.content === CONTENT.CHEST) icon = "üéÅ";
    if(tile.content === CONTENT.ART) icon = "üè∫";

    if(tile.content === CONTENT.GEM) glow(cx,cy, 62*dpr, "rgba(74,163,255,.14)");
    if(tile.content === CONTENT.CHEST) glow(cx,cy, 74*dpr, "rgba(255,204,102,.18)");
    if(tile.content === CONTENT.ART) glow(cx,cy, 86*dpr, "rgba(255,204,102,.20)");

    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = `${22*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(icon, cx, cy);

    if(tile.content === CONTENT.EMPTY){
      ctx.fillStyle = "rgba(169,182,214,.70)";
      ctx.font = `${11*dpr}px system-ui, Segoe UI, Arial`;
      ctx.fillText("empty", cx, y+h*0.80);
    }
  }

  ctx.restore();
}

function drawHUD(){
  const h = 58*dpr;
  const y = H - h - 14*dpr;

  ctx.save();
  rr(14*dpr, y, W-28*dpr, h, 18*dpr);
  ctx.fillStyle = "rgba(0,0,0,.28)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 2*dpr;
  ctx.stroke();

  // left: mission
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText("MISSION: Find 5 chests", 28*dpr, y + h/2);

  // center: energy dots
  const ex = W*0.48;
  ctx.fillStyle = "rgba(169,182,214,.92)";
  ctx.fillText("ENERGY", ex - 66*dpr, y + h/2);
  for(let i=0;i<START_ENERGY;i++){
    const px = ex + i*10*dpr - (START_ENERGY*10*dpr)/2 + 72*dpr;
    const py = y + h/2;
    const on = i < state.energy;
    ctx.globalAlpha = on ? 1 : 0.22;
    glow(px,py,16*dpr, on ? "rgba(61,220,151,.16)" : "rgba(255,255,255,.04)");
    ctx.fillStyle = on ? "rgba(61,220,151,.85)" : "rgba(255,255,255,.25)";
    ctx.beginPath(); ctx.arc(px,py,3.2*dpr,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // right: streak
  ctx.textAlign = "right";
  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.fillText(`STREAK ${state.streak}`, W-28*dpr, y + h/2);

  ctx.restore();
}

function drawBanners(){
  for(const b of state.banners){
    const a = clamp(b.life/130, 0, 1);
    const y = 34*dpr + (1-a)*-10*dpr;

    ctx.save();
    ctx.globalAlpha = 0.92 * a;

    const w = Math.min(W-40*dpr, 520*dpr);
    const x = (W-w)/2;
    rr(x, y, w, 40*dpr, 14*dpr);

    let bg = "rgba(0,0,0,.34)";
    let br = "rgba(255,255,255,.14)";
    if(b.theme === "amber"){
      bg = "rgba(255,204,102,.14)";
      br = "rgba(255,204,102,.30)";
    }
    ctx.fillStyle = bg; ctx.fill();
    ctx.strokeStyle = br; ctx.lineWidth = 2*dpr; ctx.stroke();

    ctx.fillStyle = "rgba(234,240,255,.95)";
    ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(b.text, W/2, y + 20*dpr);

    ctx.restore();
  }
}

function drawParticles(){
  // dust
  for(const p of state.dust){
    ctx.save();
    ctx.globalAlpha = clamp(p.life/38, 0, 1) * 0.85;
    ctx.fillStyle = p.good ? "rgba(255,255,255,.70)" : "rgba(255,92,108,.60)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.s*dpr, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  // sparkles / coins
  for(const p of state.particles){
    ctx.save();
    ctx.globalAlpha = clamp(p.life/52, 0, 1);
    if(p.kind === "coin"){
      ctx.fillStyle = "rgba(255,204,102,.90)";
      rr(p.x-2.6*dpr*p.s, p.y-2.6*dpr*p.s, 5.2*dpr*p.s, 5.2*dpr*p.s, 2.0*dpr);
      ctx.fill();
    }else{
      ctx.fillStyle = "rgba(255,204,102,.85)";
      rr(p.x-2.2*dpr*p.s, p.y-2.2*dpr*p.s, 4.4*dpr*p.s, 4.4*dpr*p.s, 1.3*dpr);
      ctx.fill();
    }
    ctx.restore();
  }
  // floaties
  for(const f of state.floaties){
    ctx.save();
    ctx.globalAlpha = clamp(f.life/76, 0, 1);
    let color = "rgba(169,182,214,.92)";
    if(f.kind === "good") color = "rgba(61,220,151,.92)";
    if(f.kind === "bad") color = "rgba(255,92,108,.92)";
    ctx.fillStyle = color;
    ctx.font = `${13*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(f.text, f.x, f.y);
    ctx.restore();
  }
}

function drawVignette(){
  // dark edges for cinematic look
  const g = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.15, W/2, H/2, Math.max(W,H)*0.65);
  g.addColorStop(0, "rgba(0,0,0,0)");
  g.addColorStop(1, "rgba(0,0,0,.35)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

/* ---------- Loop ---------- */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last = now;
  state.t += dt;

  // Animate mined tiles -> reveal
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      const tile = state.grid[r][c];
      if(!tile.revealed && tile.breaking > 0){
        tile.breaking = Math.min(1, tile.breaking + dt*2.4);
        if(tile.breaking >= 0.92){
          tile.breaking = 0;
          applyReveal(r,c);
        }
      }
    }
  }

  // particles physics
  for(const p of state.dust){
    p.x += p.vx * 70 * dt;
    p.y += p.vy * 70 * dt;
    p.vy += 0.18 * 70 * dt;
    p.life -= 1;
  }
  state.dust = state.dust.filter(p=> p.life > 0);

  for(const p of state.particles){
    p.x += p.vx * 70 * dt;
    p.y += p.vy * 70 * dt;
    p.vy += 0.14 * 70 * dt;
    p.life -= 1;
  }
  state.particles = state.particles.filter(p=> p.life > 0);

  for(const f of state.floaties){
    f.y += f.vy * 70 * dt;
    f.life -= 1;
  }
  state.floaties = state.floaties.filter(f=> f.life > 0);

  for(const b of state.banners) b.life -= 1;
  state.banners = state.banners.filter(b=> b.life > 0);

  // motes drift
  for(const m of state.motes){
    m.x += m.vx * 60 * dt;
    m.y += m.vy * 60 * dt;
    if(m.x < -10*dpr) m.x = W + 10*dpr;
    if(m.x > W + 10*dpr) m.x = -10*dpr;
    if(m.y < -10*dpr) m.y = H + 10*dpr;
    if(m.y > H + 10*dpr) m.y = -10*dpr;
  }

  // miner target defaults near board bottom-left
  if(state.miner.tx === 0 && state.miner.ty === 0){
    state.miner.x = board.x + board.cell*0.25;
    state.miner.y = board.y + board.h - board.cell*0.15;
    state.miner.tx = state.miner.x;
    state.miner.ty = state.miner.y;
  }

  // flash/shake
  state.flash = Math.max(0, state.flash - dt*2.4);
  state.shake = Math.max(0, state.shake - dt*2.8);

  // render
  ctx.save();
  if(state.shake > 0){
    const mag = 6*dpr*state.shake;
    ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
  }

  drawBackground(state.t);
  drawBoardFrame();

  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      drawTile(r,c,state.t);
    }
  }

  drawMiner(state.t);
  drawParticles();
  drawBanners();
  drawHUD();
  drawVignette();

  // red flash overlay on wrong answer
  if(state.flash > 0){
    ctx.save();
    ctx.globalAlpha = 0.18 * state.flash;
    ctx.fillStyle = "rgba(255,92,108,.95)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  ctx.restore();
  requestAnimationFrame(tick);
}

/* ---------- Reset ---------- */
function reset(){
  state.energy = START_ENERGY;
  state.score = 0;
  state.treasures = 0;
  state.streak = 0;
  state.gameOver = false;
  state.selected = null;
  state.locked = false;

  state.flash = 0;
  state.shake = 0;
  state.particles.length = 0;
  state.dust.length = 0;
  state.floaties.length = 0;
  state.banners.length = 0;

  buildGrid();
  updateHUD();

  // miner initial
  state.miner.tx = 0; state.miner.ty = 0; state.miner.swing = 0;

  el.qText.textContent = "Click a rock tile to start‚Ä¶";
  el.opts.innerHTML = "";
  el.fb.className = "fb";
  el.continueBtn.textContent = "Continue";
  el.retryBtn.style.display = "inline-block";
}

resize();
seedMotes();
reset();
requestAnimationFrame(tick);
</script>
</body>
</html>
